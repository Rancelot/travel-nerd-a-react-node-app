{"ast":null,"code":"'use strict';\n/**\r\n * A worker that does nothing but passing chunks to the next one. This is like\r\n * a nodejs stream but with some differences. On the good side :\r\n * - it works on IE 6-9 without any issue / polyfill\r\n * - it weights less than the full dependencies bundled with browserify\r\n * - it forwards errors (no need to declare an error handler EVERYWHERE)\r\n *\r\n * A chunk is an object with 2 attributes : `meta` and `data`. The former is an\r\n * object containing anything (`percent` for example), see each worker for more\r\n * details. The latter is the real data (String, Uint8Array, etc).\r\n *\r\n * @constructor\r\n * @param {String} name the name of the stream (mainly used for debugging purposes)\r\n */\n\nfunction GenericWorker(name) {\n  // the name of the worker\n  this.name = name || \"default\"; // an object containing metadata about the workers chain\n\n  this.streamInfo = {}; // an error which happened when the worker was paused\n\n  this.generatedError = null; // an object containing metadata to be merged by this worker into the general metadata\n\n  this.extraStreamInfo = {}; // true if the stream is paused (and should not do anything), false otherwise\n\n  this.isPaused = true; // true if the stream is finished (and should not do anything), false otherwise\n\n  this.isFinished = false; // true if the stream is locked to prevent further structure updates (pipe), false otherwise\n\n  this.isLocked = false; // the event listeners\n\n  this._listeners = {\n    'data': [],\n    'end': [],\n    'error': []\n  }; // the previous worker, if any\n\n  this.previous = null;\n}\n\nGenericWorker.prototype = {\n  /**\r\n   * Push a chunk to the next workers.\r\n   * @param {Object} chunk the chunk to push\r\n   */\n  push: function push(chunk) {\n    this.emit(\"data\", chunk);\n  },\n\n  /**\r\n   * End the stream.\r\n   * @return {Boolean} true if this call ended the worker, false otherwise.\r\n   */\n  end: function end() {\n    if (this.isFinished) {\n      return false;\n    }\n\n    this.flush();\n\n    try {\n      this.emit(\"end\");\n      this.cleanUp();\n      this.isFinished = true;\n    } catch (e) {\n      this.emit(\"error\", e);\n    }\n\n    return true;\n  },\n\n  /**\r\n   * End the stream with an error.\r\n   * @param {Error} e the error which caused the premature end.\r\n   * @return {Boolean} true if this call ended the worker with an error, false otherwise.\r\n   */\n  error: function error(e) {\n    if (this.isFinished) {\n      return false;\n    }\n\n    if (this.isPaused) {\n      this.generatedError = e;\n    } else {\n      this.isFinished = true;\n      this.emit(\"error\", e); // in the workers chain exploded in the middle of the chain,\n      // the error event will go downward but we also need to notify\n      // workers upward that there has been an error.\n\n      if (this.previous) {\n        this.previous.error(e);\n      }\n\n      this.cleanUp();\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Add a callback on an event.\r\n   * @param {String} name the name of the event (data, end, error)\r\n   * @param {Function} listener the function to call when the event is triggered\r\n   * @return {GenericWorker} the current object for chainability\r\n   */\n  on: function on(name, listener) {\n    this._listeners[name].push(listener);\n\n    return this;\n  },\n\n  /**\r\n   * Clean any references when a worker is ending.\r\n   */\n  cleanUp: function cleanUp() {\n    this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n    this._listeners = [];\n  },\n\n  /**\r\n   * Trigger an event. This will call registered callback with the provided arg.\r\n   * @param {String} name the name of the event (data, end, error)\r\n   * @param {Object} arg the argument to call the callback with.\r\n   */\n  emit: function emit(name, arg) {\n    if (this._listeners[name]) {\n      for (var i = 0; i < this._listeners[name].length; i++) {\n        this._listeners[name][i].call(this, arg);\n      }\n    }\n  },\n\n  /**\r\n   * Chain a worker with an other.\r\n   * @param {Worker} next the worker receiving events from the current one.\r\n   * @return {worker} the next worker for chainability\r\n   */\n  pipe: function pipe(next) {\n    return next.registerPrevious(this);\n  },\n\n  /**\r\n   * Same as `pipe` in the other direction.\r\n   * Using an API with `pipe(next)` is very easy.\r\n   * Implementing the API with the point of view of the next one registering\r\n   * a source is easier, see the ZipFileWorker.\r\n   * @param {Worker} previous the previous worker, sending events to this one\r\n   * @return {Worker} the current worker for chainability\r\n   */\n  registerPrevious: function registerPrevious(previous) {\n    if (this.isLocked) {\n      throw new Error(\"The stream '\" + this + \"' has already been used.\");\n    } // sharing the streamInfo...\n\n\n    this.streamInfo = previous.streamInfo; // ... and adding our own bits\n\n    this.mergeStreamInfo();\n    this.previous = previous;\n    var self = this;\n    previous.on('data', function (chunk) {\n      self.processChunk(chunk);\n    });\n    previous.on('end', function () {\n      self.end();\n    });\n    previous.on('error', function (e) {\n      self.error(e);\n    });\n    return this;\n  },\n\n  /**\r\n   * Pause the stream so it doesn't send events anymore.\r\n   * @return {Boolean} true if this call paused the worker, false otherwise.\r\n   */\n  pause: function pause() {\n    if (this.isPaused || this.isFinished) {\n      return false;\n    }\n\n    this.isPaused = true;\n\n    if (this.previous) {\n      this.previous.pause();\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Resume a paused stream.\r\n   * @return {Boolean} true if this call resumed the worker, false otherwise.\r\n   */\n  resume: function resume() {\n    if (!this.isPaused || this.isFinished) {\n      return false;\n    }\n\n    this.isPaused = false; // if true, the worker tried to resume but failed\n\n    var withError = false;\n\n    if (this.generatedError) {\n      this.error(this.generatedError);\n      withError = true;\n    }\n\n    if (this.previous) {\n      this.previous.resume();\n    }\n\n    return !withError;\n  },\n\n  /**\r\n   * Flush any remaining bytes as the stream is ending.\r\n   */\n  flush: function flush() {},\n\n  /**\r\n   * Process a chunk. This is usually the method overridden.\r\n   * @param {Object} chunk the chunk to process.\r\n   */\n  processChunk: function processChunk(chunk) {\n    this.push(chunk);\n  },\n\n  /**\r\n   * Add a key/value to be added in the workers chain streamInfo once activated.\r\n   * @param {String} key the key to use\r\n   * @param {Object} value the associated value\r\n   * @return {Worker} the current worker for chainability\r\n   */\n  withStreamInfo: function withStreamInfo(key, value) {\n    this.extraStreamInfo[key] = value;\n    this.mergeStreamInfo();\n    return this;\n  },\n\n  /**\r\n   * Merge this worker's streamInfo into the chain's streamInfo.\r\n   */\n  mergeStreamInfo: function mergeStreamInfo() {\n    for (var key in this.extraStreamInfo) {\n      if (!this.extraStreamInfo.hasOwnProperty(key)) {\n        continue;\n      }\n\n      this.streamInfo[key] = this.extraStreamInfo[key];\n    }\n  },\n\n  /**\r\n   * Lock the stream to prevent further updates on the workers chain.\r\n   * After calling this method, all calls to pipe will fail.\r\n   */\n  lock: function lock() {\n    if (this.isLocked) {\n      throw new Error(\"The stream '\" + this + \"' has already been used.\");\n    }\n\n    this.isLocked = true;\n\n    if (this.previous) {\n      this.previous.lock();\n    }\n  },\n\n  /**\r\n   *\r\n   * Pretty print the workers chain.\r\n   */\n  toString: function toString() {\n    var me = \"Worker \" + this.name;\n\n    if (this.previous) {\n      return this.previous + \" -> \" + me;\n    } else {\n      return me;\n    }\n  }\n};\nmodule.exports = GenericWorker;","map":null,"metadata":{},"sourceType":"script"}