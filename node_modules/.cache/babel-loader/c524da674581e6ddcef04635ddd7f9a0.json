{"ast":null,"code":"'use strict';\n\nvar utils = require('../utils');\n\nfunction DataReader(data) {\n  this.data = data; // type : see implementation\n\n  this.length = data.length;\n  this.index = 0;\n  this.zero = 0;\n}\n\nDataReader.prototype = {\n  /**\r\n   * Check that the offset will not go too far.\r\n   * @param {string} offset the additional offset to check.\r\n   * @throws {Error} an Error if the offset is out of bounds.\r\n   */\n  checkOffset: function checkOffset(offset) {\n    this.checkIndex(this.index + offset);\n  },\n\n  /**\r\n   * Check that the specified index will not be too far.\r\n   * @param {string} newIndex the index to check.\r\n   * @throws {Error} an Error if the index is out of bounds.\r\n   */\n  checkIndex: function checkIndex(newIndex) {\n    if (this.length < this.zero + newIndex || newIndex < 0) {\n      throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + newIndex + \"). Corrupted zip ?\");\n    }\n  },\n\n  /**\r\n   * Change the index.\r\n   * @param {number} newIndex The new index.\r\n   * @throws {Error} if the new index is out of the data.\r\n   */\n  setIndex: function setIndex(newIndex) {\n    this.checkIndex(newIndex);\n    this.index = newIndex;\n  },\n\n  /**\r\n   * Skip the next n bytes.\r\n   * @param {number} n the number of bytes to skip.\r\n   * @throws {Error} if the new index is out of the data.\r\n   */\n  skip: function skip(n) {\n    this.setIndex(this.index + n);\n  },\n\n  /**\r\n   * Get the byte at the specified index.\r\n   * @param {number} i the index to use.\r\n   * @return {number} a byte.\r\n   */\n  byteAt: function byteAt(i) {// see implementations\n  },\n\n  /**\r\n   * Get the next number with a given byte size.\r\n   * @param {number} size the number of bytes to read.\r\n   * @return {number} the corresponding number.\r\n   */\n  readInt: function readInt(size) {\n    var result = 0,\n        i;\n    this.checkOffset(size);\n\n    for (i = this.index + size - 1; i >= this.index; i--) {\n      result = (result << 8) + this.byteAt(i);\n    }\n\n    this.index += size;\n    return result;\n  },\n\n  /**\r\n   * Get the next string with a given byte size.\r\n   * @param {number} size the number of bytes to read.\r\n   * @return {string} the corresponding string.\r\n   */\n  readString: function readString(size) {\n    return utils.transformTo(\"string\", this.readData(size));\n  },\n\n  /**\r\n   * Get raw data without conversion, <size> bytes.\r\n   * @param {number} size the number of bytes to read.\r\n   * @return {Object} the raw data, implementation specific.\r\n   */\n  readData: function readData(size) {// see implementations\n  },\n\n  /**\r\n   * Find the last occurence of a zip signature (4 bytes).\r\n   * @param {string} sig the signature to find.\r\n   * @return {number} the index of the last occurence, -1 if not found.\r\n   */\n  lastIndexOfSignature: function lastIndexOfSignature(sig) {// see implementations\n  },\n\n  /**\r\n   * Read the signature (4 bytes) at the current position and compare it with sig.\r\n   * @param {string} sig the expected signature\r\n   * @return {boolean} true if the signature matches, false otherwise.\r\n   */\n  readAndCheckSignature: function readAndCheckSignature(sig) {// see implementations\n  },\n\n  /**\r\n   * Get the next date.\r\n   * @return {Date} the date.\r\n   */\n  readDate: function readDate() {\n    var dostime = this.readInt(4);\n    return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, // year\n    (dostime >> 21 & 0x0f) - 1, // month\n    dostime >> 16 & 0x1f, // day\n    dostime >> 11 & 0x1f, // hour\n    dostime >> 5 & 0x3f, // minute\n    (dostime & 0x1f) << 1)); // second\n  }\n};\nmodule.exports = DataReader;","map":null,"metadata":{},"sourceType":"script"}