{"ast":null,"code":"/*! FileSaver.js\n *  A saveAs() FileSaver implementation.\n *  2014-01-24\n *\n *  By Eli Grey, http://eligrey.com\n *  License: X11/MIT\n *    See LICENSE.md\n */\n\n/*global self */\n\n/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */\nvar saveAs = saveAs // IE 10+ (native saveAs)\n|| typeof navigator !== \"undefined\" && navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator) // Everyone else\n|| function (view) {\n  \"use strict\"; // IE <10 is explicitly unsupported\n\n  if (typeof navigator !== \"undefined\" && /MSIE [1-9]\\./.test(navigator.userAgent)) {\n    return;\n  }\n\n  var doc = view.document // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet\n  ,\n      get_URL = function get_URL() {\n    return view.URL || view.webkitURL || view;\n  },\n      URL = view.URL || view.webkitURL || view,\n      save_link = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\"),\n      can_use_save_link = !view.externalHost && \"download\" in save_link,\n      click = function click(node) {\n    var event = doc.createEvent(\"MouseEvents\");\n    event.initMouseEvent(\"click\", true, false, view, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n    node.dispatchEvent(event);\n  },\n      webkit_req_fs = view.webkitRequestFileSystem,\n      req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem,\n      throw_outside = function throw_outside(ex) {\n    (view.setImmediate || view.setTimeout)(function () {\n      throw ex;\n    }, 0);\n  },\n      force_saveable_type = \"application/octet-stream\",\n      fs_min_size = 0,\n      deletion_queue = [],\n      process_deletion_queue = function process_deletion_queue() {\n    var i = deletion_queue.length;\n\n    while (i--) {\n      var file = deletion_queue[i];\n\n      if (typeof file === \"string\") {\n        // file is an object URL\n        URL.revokeObjectURL(file);\n      } else {\n        // file is a File\n        file.remove();\n      }\n    }\n\n    deletion_queue.length = 0; // clear queue\n  },\n      dispatch = function dispatch(filesaver, event_types, event) {\n    event_types = [].concat(event_types);\n    var i = event_types.length;\n\n    while (i--) {\n      var listener = filesaver[\"on\" + event_types[i]];\n\n      if (typeof listener === \"function\") {\n        try {\n          listener.call(filesaver, event || filesaver);\n        } catch (ex) {\n          throw_outside(ex);\n        }\n      }\n    }\n  },\n      FileSaver = function FileSaver(blob, name) {\n    // First try a.download, then web filesystem, then object URLs\n    var filesaver = this,\n        type = blob.type,\n        blob_changed = false,\n        object_url,\n        target_view,\n        get_object_url = function get_object_url() {\n      var object_url = get_URL().createObjectURL(blob);\n      deletion_queue.push(object_url);\n      return object_url;\n    },\n        dispatch_all = function dispatch_all() {\n      dispatch(filesaver, \"writestart progress write writeend\".split(\" \"));\n    } // on any filesys errors revert to saving with object URLs\n    ,\n        fs_error = function fs_error() {\n      // don't create more object URLs than needed\n      if (blob_changed || !object_url) {\n        object_url = get_object_url(blob);\n      }\n\n      if (target_view) {\n        target_view.location.href = object_url;\n      } else {\n        window.open(object_url, \"_blank\");\n      }\n\n      filesaver.readyState = filesaver.DONE;\n      dispatch_all();\n    },\n        abortable = function abortable(func) {\n      return function () {\n        if (filesaver.readyState !== filesaver.DONE) {\n          return func.apply(this, arguments);\n        }\n      };\n    },\n        create_if_not_found = {\n      create: true,\n      exclusive: false\n    },\n        slice;\n\n    filesaver.readyState = filesaver.INIT;\n\n    if (!name) {\n      name = \"download\";\n    }\n\n    if (can_use_save_link) {\n      object_url = get_object_url(blob); // FF for Android has a nasty garbage collection mechanism\n      // that turns all objects that are not pure javascript into 'deadObject'\n      // this means `doc` and `save_link` are unusable and need to be recreated\n      // `view` is usable though:\n\n      doc = view.document;\n      save_link = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\");\n      save_link.href = object_url;\n      save_link.download = name;\n      var event = doc.createEvent(\"MouseEvents\");\n      event.initMouseEvent(\"click\", true, false, view, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n      save_link.dispatchEvent(event);\n      filesaver.readyState = filesaver.DONE;\n      dispatch_all();\n      return;\n    } // Object and web filesystem URLs have a problem saving in Google Chrome when\n    // viewed in a tab, so I force save with application/octet-stream\n    // http://code.google.com/p/chromium/issues/detail?id=91158\n\n\n    if (view.chrome && type && type !== force_saveable_type) {\n      slice = blob.slice || blob.webkitSlice;\n      blob = slice.call(blob, 0, blob.size, force_saveable_type);\n      blob_changed = true;\n    } // Since I can't be sure that the guessed media type will trigger a download\n    // in WebKit, I append .download to the filename.\n    // https://bugs.webkit.org/show_bug.cgi?id=65440\n\n\n    if (webkit_req_fs && name !== \"download\") {\n      name += \".download\";\n    }\n\n    if (type === force_saveable_type || webkit_req_fs) {\n      target_view = view;\n    }\n\n    if (!req_fs) {\n      fs_error();\n      return;\n    }\n\n    fs_min_size += blob.size;\n    req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {\n      fs.root.getDirectory(\"saved\", create_if_not_found, abortable(function (dir) {\n        var save = function save() {\n          dir.getFile(name, create_if_not_found, abortable(function (file) {\n            file.createWriter(abortable(function (writer) {\n              writer.onwriteend = function (event) {\n                target_view.location.href = file.toURL();\n                deletion_queue.push(file);\n                filesaver.readyState = filesaver.DONE;\n                dispatch(filesaver, \"writeend\", event);\n              };\n\n              writer.onerror = function () {\n                var error = writer.error;\n\n                if (error.code !== error.ABORT_ERR) {\n                  fs_error();\n                }\n              };\n\n              \"writestart progress write abort\".split(\" \").forEach(function (event) {\n                writer[\"on\" + event] = filesaver[\"on\" + event];\n              });\n              writer.write(blob);\n\n              filesaver.abort = function () {\n                writer.abort();\n                filesaver.readyState = filesaver.DONE;\n              };\n\n              filesaver.readyState = filesaver.WRITING;\n            }), fs_error);\n          }), fs_error);\n        };\n\n        dir.getFile(name, {\n          create: false\n        }, abortable(function (file) {\n          // delete file if it already exists\n          file.remove();\n          save();\n        }), abortable(function (ex) {\n          if (ex.code === ex.NOT_FOUND_ERR) {\n            save();\n          } else {\n            fs_error();\n          }\n        }));\n      }), fs_error);\n    }), fs_error);\n  },\n      FS_proto = FileSaver.prototype,\n      saveAs = function saveAs(blob, name) {\n    return new FileSaver(blob, name);\n  };\n\n  FS_proto.abort = function () {\n    var filesaver = this;\n    filesaver.readyState = filesaver.DONE;\n    dispatch(filesaver, \"abort\");\n  };\n\n  FS_proto.readyState = FS_proto.INIT = 0;\n  FS_proto.WRITING = 1;\n  FS_proto.DONE = 2;\n  FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;\n  view.addEventListener(\"unload\", process_deletion_queue, false);\n\n  saveAs.unload = function () {\n    process_deletion_queue();\n    view.removeEventListener(\"unload\", process_deletion_queue, false);\n  };\n\n  return saveAs;\n}(typeof self !== \"undefined\" && self || typeof window !== \"undefined\" && window || this.content); // `self` is undefined in Firefox for Android content script context\n// while `this` is nsIContentFrameMessageManager\n// with an attribute `content` that corresponds to the window\n\n\nif (typeof module !== \"undefined\") module.exports = saveAs;","map":null,"metadata":{},"sourceType":"script"}